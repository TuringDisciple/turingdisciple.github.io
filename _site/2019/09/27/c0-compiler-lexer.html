<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Writing a Compiler from Scratch in Rust Part 1: The Lexer</title>
  <meta name="description" content="Introduction In May of this year I started embarking on a project to write a full compiler for the C0 programming language. This has been something I’ve been...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" type="image/png" href="/favicon.png">
  <link rel="canonical" href="http://localhost:4000/2019/09/27/c0-compiler-lexer.html">
  <link rel="alternate" type="application/rss+xml" title="nashpotato" href="/feed.xml">
  
  
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

</head>
<body><header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">nashpotato</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/about.html">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Writing a Compiler from Scratch in Rust Part 1: The Lexer</h1>
    <p class="post-meta">
      <time datetime="2019-09-27T00:00:00+01:00" itemprop="datePublished">
        
        Sep 27, 2019
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h1 id="introduction">Introduction</h1>
<p>In May of this year I started embarking on a project to write a full compiler for the <a href="http://c0.typesafety.net/tutorial/">C0</a> programming language. This has been something I’ve been wanting to do for a while, but I had to put development of this compiler on the backburner due to university and work commitments. As of September I have picked up production of the compiler again.</p>

<p><a href="https://github.com/nashpotato/C0-Compiler">Source repo</a></p>

<h1 id="what-are-compilers">What are Compilers?</h1>
<p>For a brief primer, compilers are one of the most interesting but overlooked and underappreciated areas of CS. A compiler, as most programmers know, is involved in transforming a high level programming languages source code into something that can be understood and executed by a computer. The theory behind how these works is an active research area, and has been for decades. However, apart from compiler engineers themselves, most coders don’t really get into how compilers really work. For me personally I have always been interested in compilers, but never felt too confident in my ability to develop them. But that’s changed.</p>

<h1 id="the-compiler">The Compiler</h1>
<p>Compilers are typically split into several stages. Each stage represents a different part of the compilation stage. The diagram below illustrates these different stages.</p>

<p><img src="/assets/compiler-phases.jpg" alt="Compiler Stages" /></p>

<p>Each stage does the following</p>

<ul>
  <li><strong>Lexical analysis</strong>: in this stage we take the source code from the original program and extract out tokens which represent different lexical components.</li>
  <li><strong>Syntax analysis</strong>: in this step we build a representation of syntactic meaning called an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a>.</li>
  <li><strong>Semantic analysis</strong>: here we perform analysis on the AST</li>
  <li><strong>Intermediate code generation</strong>: here we generate something called intermediate representation code. The purpose of this step is to generate a platform independent representation of the language that can be passed for optimisation. This eliminates the need for writing optimisers that are platform dependent. So if we are compiling for an ARM processor, or a x86 processor, the IR step ensures that we optimise for a representation that is independent from these architectures before being compiled for these architectures. This is easier than writing optimisers for individual architecture languages.</li>
  <li><strong>Optimisation</strong>: this is the really fun step where code is optimised to improve performance. <a href="https://en.wikipedia.org/wiki/Optimizing_compiler#Types_of_optimization">There’s a wide range </a> of optimisations that can be performed in this step.</li>
  <li><strong>Code generation</strong>: here we generate the code that we are compiling to.</li>
  <li><strong>Target code optimisation</strong>: this step may be useful if there are optimisations that are dependent on the target code language.</li>
  <li><strong>Target code generation</strong>: here we produce the executable code for the target.</li>
</ul>

<p>The descriptions above are quite high level but cover the gist of what is going on in compilers. The purpose of this post is to discuss the lexing step which I have implemented in my compiler.</p>

<h1 id="the-lexer">The Lexer</h1>
<p>The lexer is a by far the simplest stage in the compilation step and really just involves taking the original source code, and producing tokens that represent individual language components. This is quite hard to explain in words, so let’s look at some code. Let’s look at an example C0 program</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and let’s look at the output of passing this program through the lexer</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">vec!</span><span class="p">[</span>
    <span class="nn">Token</span><span class="p">::</span><span class="n">Int</span><span class="p">,</span>
    <span class="nn">Token</span><span class="p">::</span><span class="nf">Undefined</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="sc">'m'</span><span class="p">)),</span>
    <span class="nn">Token</span><span class="p">::</span><span class="nf">Undefined</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="sc">'a'</span><span class="p">)),</span>
    <span class="nn">Token</span><span class="p">::</span><span class="nf">Undefined</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="sc">'i'</span><span class="p">)),</span>
    <span class="nn">Token</span><span class="p">::</span><span class="nf">UndefineD</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="sc">'n'</span><span class="p">)),</span>
    <span class="nn">Token</span><span class="p">::</span><span class="n">LBracket</span><span class="p">,</span>
    <span class="nn">Token</span><span class="p">::</span><span class="n">RBracket</span><span class="p">,</span>
    <span class="nn">Token</span><span class="p">::</span><span class="n">LCurly</span><span class="p">,</span>
    <span class="nn">Token</span><span class="p">::</span><span class="n">Int</span><span class="p">,</span>
    <span class="nn">Token</span><span class="p">::</span><span class="nf">Undefined</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="sc">'x'</span><span class="p">)),</span>
    <span class="nn">Token</span><span class="p">::</span><span class="nb">Eq</span><span class="p">,</span> 
    <span class="nn">Token</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="nn">Token</span><span class="p">::</span><span class="n">SemicColon</span><span class="p">,</span>
    <span class="nn">Token</span><span class="p">::</span><span class="n">Return</span><span class="p">,</span>
    <span class="nn">Token</span><span class="p">::</span><span class="nf">Undefined</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="sc">'x'</span><span class="p">)),</span>
    <span class="nn">Token</span><span class="p">::</span><span class="n">SemiColon</span><span class="p">,</span>
    <span class="nn">Token</span><span class="p">::</span><span class="n">RCurly</span><span class="p">,</span>
<span class="p">]</span>
</code></pre></div></div>

<p>What can be seen is that we’re essentially from the source language and just generating representations for key components. Notice that whitespace is ignored as for a language like C0, whitespace serves no purpose other than to make it easier to read for people. 
The reason that these tokens are encapsulated in a vector is that this is a dynamic data structure, and the data we have is ordered.</p>

<h1 id="conclusion">Conclusion</h1>
<p>Logically this isn’t hard to understand, we have just provided a representation for the entire source file by just linearly reading the source thereby giving meaning to our source. This is what makes lexers so simple. So simple in fact that some compilers completely do away with an explicit lexing step, and just parse the language straight from source. This does in a sense make this blog post redundant, and I guess it serves a greater purpose as introducing this blog series.</p>

<p>Now that our source has an attached “meaning”, we can start parsing over the source language which will be covered in part 2. The source for the lexer can be found <a href="https://github.com/nashpotato/C0-Compiler/blob/master/src/lexer/lexer.rs">here</a>.</p>


  </div>

  
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</article>


      </div>
    </main><footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">nashpotato</h2>

    <div class="footer-col-wrapper">
      

      <div class="footer-col footer-col-1">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/nashpotato"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">nashpotato</span></a>

          </li>
          
          
          <li>
                <a href="https://twitter.com/nashepotato"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">nashepotato</span></a>

          </li>
          
           
          <li><a class="u-email" href="mailto:mncubenashe@gmail.com">mncubenashe@gmail.com</a></li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
